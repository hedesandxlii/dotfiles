#!/usr/bin/python3
import argparse
import subprocess as sp
from abc import abstractmethod
from pathlib import Path
from typing import List, Protocol, Union

from termcolor import colored


ReturnCode = int
UnparsedCommand = Union[str, List[str]]

def echo_command(command: str, prefix: str):
    print(f"{prefix} {colored(command, 'cyan')}")

def echo_return_code(return_code: ReturnCode):
    is_bad = return_code != 0
    color = "red" if is_bad else "green"
    print(f"Return code: {colored(str(return_code), color)}")

class ShellCommand:
    def __init__(self, command: UnparsedCommand):
        if isinstance(command, list):
            self.command_vector = command
        elif isinstance(command, str):
            self.command_vector = command.split()

    @property
    def command_str(self) -> str:
        return ' '.join(self.command_vector)

    def truncate(self, line: str, width: int = 80) -> str:
        trunc_suffix = " ..."
        trunc_width = width - len(trunc_suffix)
        if len(line) > trunc_width:
            return line[:trunc_width] + trunc_suffix
        else:
            return line

    def _scroll_output(self, stream, width: int = 80):
        for line in stream:
            clean_line = self.truncate(line, width).strip().ljust(width)
            # appearently, `\r` moves cursor to start of line, allowing for 
            # over-writes in the same line.
            print(clean_line, end='\r', flush=True)
        print(flush=True)

    def run_output_scroll(self, **popen_kwargs) -> ReturnCode:
        proc = sp.Popen(self.command_vector,
                        encoding="utf-8", stdout=sp.PIPE, **popen_kwargs)
        assert proc.stdout is not None
        self._scroll_output(proc.stdout)
        return proc.wait()

    def run_silent(self, **popen_kwargs) -> ReturnCode:
        proc = sp.Popen(self.command_vector,
                        encoding="utf-8", stdout=sp.DEVNULL, **popen_kwargs)
        return proc.wait()

    def run_pretty(self, **popen_kwargs) -> ReturnCode:
        echo_command(self.command_str, "$")
        return_code = self.run_output_scroll(**popen_kwargs)
        echo_return_code(return_code)
        print()
        return return_code


class Dependency(Protocol):
    @abstractmethod
    def is_installed(self) -> bool: ...

    @abstractmethod
    def get_name(self) -> str: ...

    @abstractmethod
    def _uninstall(self, install_path: Path): ...

    @abstractmethod
    def _install(self, install_path: Path): ...

    def uninstall(self, install_path: Path):
        if self.is_installed():
            print("Uninstalling", self.get_name())
            self._uninstall(install_path)
        else:
            print(self.get_name(), "is not installed so can't uninstall")

    def install(self, install_path: Path):
        if not self.is_installed():
            print("Installing", self.get_name())
            self._install(install_path)
        else:
            print(self.get_name(), "is already installed")


class AbsDependency(Dependency):
    def __init__(self, name: str):
        self.name = name
        which_retcode = ShellCommand(["which", self.name]).run_silent()
        self._is_installed = which_retcode == 0

    def is_installed(self) -> bool:
        return self._is_installed

    def get_name(self) -> str:
        return self.name

    @abstractmethod
    def get_fancy_name(self) -> str: ...

    def __repr__(self) -> str:
        if self.is_installed():
            installed_string = colored("Installed", "green")
        else:
            installed_string = colored("Not installed", "red")

        return f"Name:   {self.get_fancy_name()}\n" \
               f"Status: {installed_string}"


class NVIM(AbsDependency):
    def __init__(self):
        super().__init__(name="nvim")

    def get_fancy_name(self):
        return colored(r"ℕ", "green") + " vim (neovim)"

    def _uninstall(self, install_path: Path):
        ShellCommand(f"make -C {install_path} clean").run_pretty()
        ShellCommand(f"make -C {install_path} distclean").run_pretty()
        # As per [https://github.com/neovim/neovim/wiki/Installing-Neovim#uninstall]
        ShellCommand("sudo rm /usr/local/bin/nvim").run_pretty()
        ShellCommand("sudo rm -r /usr/local/share/nvim").run_pretty()

    def _install(self, install_path: Path):
        ShellCommand(f"git clone https://github.com/neovim/neovim.git {install_path}").run_pretty()
        ShellCommand(f"git checkout stable").run_pretty(cwd=install_path.as_posix())
        ShellCommand(f"make -C {install_path} CMAKE_BUILD_TYPE=RelWithDebInfo").run_pretty()
        ShellCommand(f"sudo make -C {install_path} install").run_pretty()


class DoomNVIM(AbsDependency):
    def __init__(self):
        super().__init__(name="doom-nvim")
        self.nvim_config_dir = Path.home() / ".config" / "nvim"

    def get_fancy_name(self):
        return colored("", "red") + " nvim (doom-nvim)"

    def _install(self, install_path: Path):
        ShellCommand(
            f"git clone --depth 1 https://github.com/NTBBloodbath/doom-nvim.git {install_path}"
        ).run_pretty()
        echo_command(f"{repr(self.nvim_config_dir)}.symlink_to({install_path})", "py")
        self.nvim_config_dir.symlink_to(install_path)

    def _uninstall(self, _: Path):
        echo_command(f"{repr(self.nvim_config_dir)}.unlink()", "py")
        self.nvim_config_dir.unlink()

    def is_installed(self):
        return (self.nvim_config_dir / "doomrc.lua").exists()


def main():
    parser = argparse.ArgumentParser(
        "A lil' script that clones `NeoVim` and `Doom-Nvim` to "
        "./.deps/ and then installs/symlinks in order for them to be usable "
        "and you can be off to the races."
    )
    parser.add_argument("--install", action="store_true")
    parser.add_argument("--uninstall", action="store_true")

    args = parser.parse_args()

    github_clone_dir = Path(__file__).parent / ".deps"
    github_clone_dir.mkdir(exist_ok=True)

    nvim: Dependency = NVIM()
    doom: Dependency = DoomNVIM()

    print(10 * '=', "Dependency status:")
    print(nvim)
    print()
    print(doom)
    print()

    if args.uninstall:
        print(10 * '=', "Uninstalling:")
        nvim.uninstall(github_clone_dir / "neovim")
        doom.uninstall(github_clone_dir / "doom-nvim")
    elif args.install:
        print(10 * '=', "Installing:")
        nvim.install(github_clone_dir / "neovim")
        doom.install(github_clone_dir / "doom-nvim")

        print()
        print(colored("Note:", "yellow"), "Dont forget to run")
        print()
        print("\t`:PackerSync`")
        print()
        print("When entering nvim for the first time!")
    else:
        parser.print_usage()

if __name__ == "__main__":
    main()
